Exercise 3.1
a. Which algorithms work (in a timely manner) and which donâ€™t? Explain your results in terms of the capabilities (and implementations) of the algorithms and nature of the problems.
   - Depth first graph search fails to find the solution to the easiest sudoku puzzle in reasonable time. The number of nodes that DFS has to search is exponentially large given the problem, and it would take a long time for it to come to a solution, but it will eventually get there.
   - AC3 succeeds in the easy puzzle case, out performing DFS. But it fails on the more difficult puzzles; it does terminate, but in failure. AC3 fails to find a solution to these more complex puzzles since it doesn't do any type of guessing/backtracking. It simply reduces the search space using arc-consistency, but it won't find a solution if the solution isn't the result of the domain simplification.
   - Backtracking performs similarly to AC3, but rather than terminating in a failed state on the more complex problems, it continues searching for an unreasonable amount of time. Since it is using simple strategies for select_unassigned_variable and inference methods, it greatly increases the amount of time spent searching (a factor of 1,000 according to the book). 
b. What effect does configuring the settings for backtracking have on the results? Try the following
   i. Set the variable/value ordering (i.e., the select_unassigned_variable parameter) to first-unassigned-variable (the default) or minimum-remaining-values (i.e., mrv). 
   ii. Set the inference (i.e., the inference parameter) to forward-checking (i.e., forward_checking).
   Which, if any, of these settings should work best for sudoku? What combination of settings actually works the best?
   The combination of MRV (minimum-remaining-value) and forward-checking work together to efficiently solve the puzzle. MRV searches in the next logical cell (the one with the most constraints), and forward-checking makes sure the choice is arc-consistent before exploring the option. Another way to solve the problem in a similar fashion is to run the puzzle through AC3 and then pass it onto the backtracking with only MRV. AC3 makes the puzzle arc-consistent, so foward checking is not needed when running backtracking.
